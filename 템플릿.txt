/*
- 템플릿이란 = 
- 컴파일러가 미리 등록된 함수의 형틀을 기억해 두었다가
  함수가 호출될때 실제 함수를 만드는 장치

템플릿: 여러가지 함수, 클래스를 찍어내는 틀
-> 템플릿의 종류는 함수 템플릿과 클래스 템플릿이 있다.

함수 템플릿: 함수위에 템플릿이 선언되며 함수 템플릿은 함수마다 선언을 해줘야한다.

클래스 템플릿: 클래스 위에 선언이 되며 클래스마다 선언을 하는걸 원칙으로 한다.

- 템플릿 특징 -
- 템플릿은 정의만 하고 함수를 호출하지 않으면 아무런 일도 일어나지 않는다.
-> 템플릿 자체는 메모리를 소모하지 않는다.
-> 호출에 의해 템플릿이 구체화 되어 실제 함수가 될 때만 프로그램의 크기가 늘어난다. 클래스 템플릿은 아니다.

=================================================================================================

-헤더파일에 함수를 직접 구현하는 경우

1. 캡술화(설정자ㅡ 접근자 함수들)
- C++은 객체지향언어 -> 캡슐화는 OOP의 특성중 하나

2. 템플릿
- 헤더와 cpp로 구분 지어 코드를 구현하는게 불가능한건 아니지만
  템플릿은 헤더파일에 구현하는걸 권장-> 보통은 컴파일러가 에러를 미친듯이 뿜어낸다.

3. 인라인(inline) 함수
- 복잡한 함수 구조나 연산이 굉장히 많은 로직을 구현할때는 
  필연적으로 스택오버 플로어 발생 여지가 있다.
-> 궁극적으로 실행속도 향상을 위해 사용할 수 있다.
-> 함수가 호출되면 스택의 할당과 반환이라는 과정이 일어나는데 인라인은 그런거 없다.

적용의 좋은 예
1, 간결한 코드에 사용하면 좋다,
-> 인라인 키드워드는 어디까지나 컴파일러에게 명시적으로 알려주는 키워드
   컴파일러가 함수를 인라인화 시킬건지 아닌지는 결국 자기 마음
   반대로 인라인 키워드가 없어도 컴파일러가 함수를 인라인화 시키는 경우도 있다

- 인라인 함수가 왜 필요한지에 대해서 알려고하면 하면 매크로의 장점과 단점을 알 필요가 있다.

	- #define add(x) ((x) * (x))

-위 와 같은 매크로를 inline으로 정의하려고 하면 뭐가 필요하냐면 많은 수의 함수가 필요하다
  -> 오버로딩이 일어나야 한다

-함수를 inline으로 사용할때 자료형에 독립적으로 선언하는 방법이 있다면 템플릿

매크로 vs function
읽히는 시간
매크로는 전처리기 데이터 영역 주소를 접근할수가 없다. 값의 변동 여부?? 확장성이 ㄴㄴ
function 컴파일러 스택 

인라인은 자료형에 독집저이지 못해서 오버로딩이 필요하고 함수가 많이 늘어난다. 이런짓을 하기가싫어서 템플릿이 쓴다.

*/